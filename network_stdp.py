# -----------------------------------------------------------------------
# SUPPLEMENTARY MATERIAL to the article:
#
# Stephan Henker, Johannes Partzsch and Rene Schueffny (2011):
# Accuracy evaluation of numerical methods used in state-of-the-art simulators for spiking neural networks,
# Journal of Computational Neuroscience
#
# -----------------------------------------------------------------------
# Company         :   Technische Universitaet Dresden                      
# Author          :   partzsch            
# E-Mail          :   Johannes.Partzsch@tu-dresden.de                	
#------------------------------------------------------------------------
# Description: calculate STDP weight change for each pair of neurons from list of pulses
#              Writes weights as matrix to output file
#
# Usage:       python network_stdp.py <inputfile>
#              <inputfile> is a spike file generated by brunel.py
#              The weight matrix is stored in <inputfile>.stdp
#
#------------------------------------------------------------------------


import numpy
from math import exp
import sys

spikefile = 'files/spikes_brian_g3_r10_d2_exc.txt'

if len(sys.argv) >= 2:
	spikefile = sys.argv[1]




# PyNN output
min_spikeid = 0
max_spikeid = 119
timebase = 0.001 # in seconds: set to 0.001 for ms time base (for PyNN output)

# symmetric window (Song, 2000)
tau_pot = 0.02 # in seconds
tau_dep = 0.02
a_pot = 0.02
a_dep = 0.02


sp_times = numpy.loadtxt(spikefile) # read spikes from file

sortind = numpy.argsort(sp_times,axis=0)
sp_times = sp_times[sortind[:,0],:]

weights = numpy.zeros([max_spikeid-min_spikeid+1, max_spikeid-min_spikeid+1])
last_t = numpy.zeros(max_spikeid-min_spikeid+1)

sp_count = sp_times.shape[0]

valid_spike_count = 0

for nsp in range(sp_count):
	curr_time = sp_times[nsp,0]*timebase
	curr_id = int(sp_times[nsp,1])-min_spikeid
	
	if ((curr_id <= max_spikeid-min_spikeid) and (curr_id >= 0)):
		valid_spike_count += 1
	
		for nsyn in range(max_spikeid-min_spikeid+1):
			curr_last_t = last_t[nsyn]
			if (curr_last_t > curr_time):
				print('Warning: unsorted spike list at pos. '+str(nsp))
				stop()

			if (curr_last_t > 0.0): # only include actual spikes (no calculation back to starting time)
				# pre-post (current spike is post spike)
				weights[nsyn,curr_id] += a_pot*exp(-(curr_time-curr_last_t)/tau_pot)
				# post-pre (current spike is pre spike)
				weights[curr_id,nsyn] -= a_dep*exp(-(curr_time-curr_last_t)/tau_dep)
		
		last_t[curr_id] = curr_time



numpy.savetxt(spikefile+'.stdp',weights)

print('Calculated STDP over '+str(valid_spike_count)+' spikes.')
